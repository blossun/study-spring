## 스프링 시큐리티 OAuth 2 설정: 인증 서버 설정

```xml
<dependency>
  <groupId>org.springframework.security</groupId>
  <artifactId>spring-security-test</artifactId>
  <version>${spring-security.version}</version>
  <scope>test</scope>
</dependency>
```

토큰 발행 테스트

* User
* Client
* POST /oauth/token
  * HTTP Basic 인증 헤더 (클라이언트 아이디 + 클라이언트 시크릿)
  * 요청 매개변수 (MultiValuMap<String, String>)
    * grant_type: password
    * username
    * password
  * 응답에 access_token 나오는지 확인

Grant Type: Password

* Granty Type: 토큰 받아오는 방법
* 서비스 오너가 만든 클라이언트에서 사용하는 Grant Type
* https://developer.okta.com/blog/2018/06/29/what-is-the-oauth2-password-grant

AuthorizationServer 설정

* @EnableAuthorizationServer
* extends AuthorizationServerConfigurerAdapter
* configure(AuthorizationServerSecurityConfigurer security)
  * PassswordEncode 설정
* configure(ClientDetailsServiceConfigurer clients)
  * 클라이언트 설정
  * grantTypes
    * password
    * refresh_token
  * scopes
  * secret / name
  * accessTokenValiditySeconds
  * refreshTokenValiditySeconds
* AuthorizationServerEndpointsConfigurer
  * tokenStore
  * authenticationMaanger
  * userDetailsService

---

## 다른 OAuth2 인증 처리 방식

클라이언트(Account)가 인증을 받으려면 써드파티 앱이기 때문에 페이스북, 구글등 유저의 진짜 인증정보를 가지고있는 서버에 리다이랙션이 일어난다.

토큰을 발급 받을 수 있는 또 다른 토큰을 먼저 받고, 다음에 토큰을 받고, 다시 리다이렉션이 일어난다. 홉이 굉장히 많음.

## Grant Type

* 스프링 OAuth가 인증을 제공하는 6가지 방법 중 `Password`와 `RefreshToken` 두 가지 방법을 지원하도록 구현한다.

* 최초에 OAuth 토큰을 발급받을 때는 Password라는 GrantType으로 발급 받는다.
* Password Grant Type은 다른 인증방식과 다른 특징이 있다.
  * 홉이 한번이다. 요청-응답이 한 쌍으로 한 번으로 토큰을 바로 받을 수 있다.

* 인증을 제공하는 서비스들이 만든 앱(ex. facebook, google)들이 사용하는 방식
* 언제 Password Grant Type을 쓸 수 있을까?
  * 유저의 유저네임과 패스워드를 직접 요구하므로 써드파티한테 이 방식을 허용하면 안되고
    오로지 사용자 인증 정보를 보유하고 있는 서비스에서만 허용해야하는 인증 방법
  * 장점은 정보를 보내면 응답으로 바로 한번에 액세스 토큰을 받을 수 있음
  * 서비스 오너가 만든 클라이언트에서 사용하는 **Grant Type**



### Grant Type: Password 요청시 필요한 정보

`client_id`, `client_secret`는 **basic Authentication** 형태로 **Header**에 넣고,
`grant_type=password`, `username`, `password` 는 **Request**에 파라메터로 넘겨줄 수 있다.

```
grant_type=password
&username=exampleuser
&password=1234luggage
&client_id=xxxxxxxxxx
```



## 테스트코드

* 일종의 컨트롤러 테스트이기 때문에 BaseControllerTest를 상속

* 기본으로 **OAuth2** 서버가 등록이 되면 `/oauth/token`을 요청할 수 있는 핸들러가 적용이 됨

HttpBasic를 사용하기 위해 spring-security-test 의존성 추가

```xml
<dependency>
  <groupId>org.springframework.security</groupId>
  <artifactId>spring-security-test</artifactId>
  <version>${spring-security.version}</version>
  <scope>test</scope>
</dependency>
```



**HttpBasic**를 사용하기 위해선 **clientId**와 **clientSecret** 가 필요

```java
public class AuthServerConfigTest extends BaseControllerTest {

    @Autowired
    AccountService accountService;

    @Test
    @TestDescription("인증 토큰을 발급 받는 테스트")
    public void getAuthToken() throws Exception {
        // Given
        String username = "solar@email.com";
        String password = "solar";
        Account solar = Account.builder()
                .email(username)
                .password(password)
                .roles(Set.of(AccountRole.ADMIN, AccountRole.USER))
                .build();
        this.accountService.saveAccount(solar);

        String clientId = "myApp";
        String clientSecret = "pass";

      	// When & Then
        this.mockMvc.perform(post("/oauth/token")
                    .with(httpBasic(clientId, clientSecret)) // Basic OAuth Header
                    .param("username", username)
                    .param("password", password)
                    .param("grant_type", "password"))
                .andDo(print())
                .andExpect(status().isOk())
                .andExpect(jsonPath("access_token").exists());
    }

}
```



## 인증 서버 설정

이 설정이 완료되면 인증토큰을 발급받을 수 있어야 한다.







