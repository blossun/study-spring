# 빈의 스코프

**스코프**
	● 싱글톤
	● 프로토타입
			○ Request
			○ Session
			○ WebSocket
			○ ...

**프로토타입 빈이 싱글톤 빈을 참조하면?**

​	● 아무 문제 없음.

**싱글톤 빈이 프로토타입 빈을 참조하면?**
	● 프로토타입 빈이 업데이트가 안되네?
	● 업데이트 하려면
			○ scoped-proxy
			○ Object-Provider
			○ Provider (표준)

**프록시**

* [프록시패턴](https://en.wikipedia.org/wiki/Proxy_pattern)

**싱글톤 객체 사용시 주의할 점**
	● 프로퍼티가 공유.
	● ApplicationContext 초기 구동시 인스턴스 생성.

---

## 스코프

* 기본적으로 빈은 `싱글톤` 스코프를 가진다.

* 다른 스코프를 가질 수 있지만 대부분의 경우에는 싱글톤 스코프만 쓰게될 것이다.

* 해당 인스턴스를 어떠한 스코프에 따라 새로 만들어야 되는 경우에는 스포크를 변경해줘야 한다.

  

#### 싱글톤

애플리케이션 전반에 걸쳐서 해당 빈의 인스턴스가 오직 한개 뿐이다.



※  [실습] 

Proto와 Single 클래스를 만들어주고 @Component로 빈등록

Single이 Proto를 가지도록 한다.

```java
@Component
public class Single {

    @Autowired
    Proto proto;

    public Proto getProto() {
        return proto;
    }
}
```

```java
@Component
public class Proto {}
```



ApplicationRunner를 구현한 클래스를 생성해서 직접 주입받은 Proto와 Single이 주입받은 Proto 정보를 출력

```java
@Component
public class AppRunner implements ApplicationRunner {

    @Autowired
    Single single;

    @Autowired
    Proto proto;


    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println(proto); //AppRunner가 주입받은 proto
        System.out.println(single.getProto()); //Single 객체가 주입받은 proto
    }
}
```

![스크린샷 2020-07-08 오후 7.59.01](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggjrmek49gj30rn06sjsk.jpg)



⇒ **두 인스턴스가 동일하다**는 것을 알 수 있다.



#### 프로토타입

매번 새로운 인스턴스를 만들어서 사용하는 스코프

* 빈을 주입받을 때 마다 새로운 인스턴스가 받아진다.

```java
@Component @Scope("prototype")
public class Proto {}
```



프로토타입 빈과 싱글톤 타입 빈을 3번씩 가져와서 출력해보자

```java
@Component
public class AppRunner implements ApplicationRunner {
    @Autowired
    ApplicationContext ctx;

    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println("proto");
        System.out.println(ctx.getBean(Proto.class));
        System.out.println(ctx.getBean(Proto.class));
        System.out.println(ctx.getBean(Proto.class));

        System.out.println("single");
        System.out.println(ctx.getBean(Single.class));
        System.out.println(ctx.getBean(Single.class));
        System.out.println(ctx.getBean(Single.class));
    }
}
```

![프로토타입 싱글톤 비교](https://i.imgur.com/zSircGf.png)



⇒ 프로토타입은 호출 시마다 새로운 인스턴스를 만들고, 싱글톤은 동일한 인스턴스임을 확인할 수 있다.



## 스코프를 혼용해서 사용했을 경우 문제

이렇게 간단하게 빈의 인스턴스의 스코프를 관리할 수 있는 것이 스프링의 장점이다.

하지만 혼용해서 쓰이면 복잡해진다.

#### ※ 프로토타입 빈이 싱글톤 빈을 참조하면?

프로토타입의 빈에 싱글톤을 사용하는 것은 아무 문제가 없다.

Proto 타입의 빈은 매번 새로 생성되겠지만, Proto 타입이 참조하는 Single 톤은 언제나 동일하다.

의도한 대로 쓰이므로 문제가 없다.

```java
@Component @Scope("prototype")
public class Proto {
    @Autowired
    Single single;
}
```



#### ※ 싱글톤 빈이 프로토타입 빈을 참조하면?

싱글톤 스코프에서 프로토타입 스코프의 빈을 사용한다면?

싱글톤 빈은 인스턴스가 한번만 만들어진다. 한번 만들어질 때, 이 프로토타입 스코프의 프로퍼티도 이미 셋팅이 된다.

따라서 싱글톤 빈을 계속해서 쓸 때, 프로토타입 스코프의 빈이 새롭게 만들어지지 않고, 처음 셋팅된 인스턴스만 가지고 사용이 된다. 이것이 문제이다.



```java
@Component
public class Single {

    @Autowired
    Proto proto;

    public Proto getProto() {
        return proto;
    }
}
```

```java
@Component
public class AppRunner implements ApplicationRunner {

    @Autowired
    ApplicationContext ctx;

    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println("proto by single");
        System.out.println(ctx.getBean(Single.class).getProto());
        System.out.println(ctx.getBean(Single.class).getProto());
        System.out.println(ctx.getBean(Single.class).getProto());
    }
}
```

![싱글톤이 참조하는 프로토타입](https://i.imgur.com/Rfinyfb.png)



⇒ 문제점 : 싱글톤 빈에서 참조하고 있는 프로토타입의 빈의 인스턴스가 변경되지 않는다.



































